mainmodule ParticleExercise {

  include "Particle.h";

  readonly CProxy_Main mainProxy;
  readonly CProxy_Cell cellProxy;
  readonly int particlesPerCell;
  readonly int cellDimension;

  mainchare Main {
    entry Main(CkArgMsg* m);
    //TODO: add an entry methods to receive the reductions
    entry [reductiontarget] void done();
    entry void Result(CkReductionMsg *msg);
  };

  array [2D] Cell {
    entry Cell(void);
    entry void updateNeighbor(int iter, std::vector<Particle> incoming);
    entry void ResumeFromSync();

    // Main computation
    entry void run() {
        for(iteration=0; iteration<ITERATION; iteration++){
          serial "Send Particles" {
            //TODO: Call updateParticles
            updateParticles();

            //TODO: Collect incoming particles from 4 neighbours
            int x = thisIndex.x;
            int y = thisIndex.y;

            thisProxy(wrap_chare(x+1),wrap_chare(y)).updateNeighbor(iteration, E);
            thisProxy(wrap_chare(x+1),wrap_chare(y+1)).updateNeighbor(iteration, SE);
            thisProxy(wrap_chare(x)  ,wrap_chare(y+1)).updateNeighbor(iteration, S);
            thisProxy(wrap_chare(x-1),wrap_chare(y+1)).updateNeighbor(iteration, SW);
            thisProxy(wrap_chare(x-1),wrap_chare(y)).updateNeighbor(iteration, W);
            thisProxy(wrap_chare(x-1),wrap_chare(y-1)).updateNeighbor(iteration, NW);
            thisProxy(wrap_chare(x)  ,wrap_chare(y-1)).updateNeighbor(iteration, N);
            thisProxy(wrap_chare(x+1),wrap_chare(y-1)).updateNeighbor(iteration, NE);
          }

          for(count_neighbours = 0 ; count_neighbours < 8 ; count_neighbours ++) { 
            when updateNeighbor[iteration](int iter, std::vector<Particle> incoming) 
            serial "Receive Particles"{
                particles.insert( particles.end(), incoming.begin(), incoming.end());  
            }
          }
          
          if(iteration % LB_INTERVAL == 0 ) {
            serial {
              AtSync();
            }
            when ResumeFromSync() {}
          }

          //TODO: Add contribute calls for reductions of max and avg calculation
          if(0 == iteration%10) serial "Sending Result" {
              int size =  particles.size();
              int reduction_array[3];
              reduction_array[0]  = iteration;
              reduction_array[1]  = size;
              reduction_array[2]  = size;
              //CkPrintf("[%d %d] Data: %d \n", thisIndex.x, thisIndex.y, size);
              
              CkCallback cb(CkIndex_Main::Result(NULL), mainProxy);
              contribute(3*sizeof(int), reduction_array, maxAndAvgType,cb);
        
          }

        }//end of the iteration loop

        //TODO: Add contribute call for finishing the execution
        serial "Work Done" {
          contribute(CkCallback(CkReductionTarget(Main, done), mainProxy));
        }
    };
  };

  initproc void registerMaxAndAvg(void);
};
