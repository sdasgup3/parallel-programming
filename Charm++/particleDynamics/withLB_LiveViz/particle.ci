mainmodule ParticleExercise {

  include "Particle.h";

  readonly CProxy_Main mainProxy;
  readonly CProxy_Cell cellProxy;
  readonly int particlesPerCell;
  readonly int cellDimension;
  readonly double centreSquare_xMin ;
  readonly double centreSquare_xMax; 
  readonly double centreSquare_yMin ;
  readonly double centreSquare_yMax  ;


  mainchare Main {
    entry Main(CkArgMsg* m);
    //TODO: add an entry methods to receive the reductions
    entry [reductiontarget] void done();
    entry void Result(CkReductionMsg *msg);
  };

  array [2D] Cell {
    entry Cell(void);
    entry void updateNeighbor(int iter, std::vector<Particle> incoming);
    entry void requestNextFrame(liveVizRequestMsg *m);
    entry void ResumeFromSync();


    // Main computation
    entry void run() {
        for(iteration=0; iteration<ITERATION; iteration++){
          serial "Send Particles" {
            //TODO: Call updateParticles
            updateParticles();

            //TODO: Collect incoming particles from 4 neighbours
            int x = thisIndex.x;
            int y = thisIndex.y;

            thisProxy(wrap_chare(x+1),wrap_chare(y)).updateNeighbor(iteration, E);
            thisProxy(wrap_chare(x+1),wrap_chare(y+1)).updateNeighbor(iteration, SE);
            thisProxy(wrap_chare(x)  ,wrap_chare(y+1)).updateNeighbor(iteration, S);
            thisProxy(wrap_chare(x-1),wrap_chare(y+1)).updateNeighbor(iteration, SW);
            thisProxy(wrap_chare(x-1),wrap_chare(y)).updateNeighbor(iteration, W);
            thisProxy(wrap_chare(x-1),wrap_chare(y-1)).updateNeighbor(iteration, NW);
            thisProxy(wrap_chare(x)  ,wrap_chare(y-1)).updateNeighbor(iteration, N);
            thisProxy(wrap_chare(x+1),wrap_chare(y-1)).updateNeighbor(iteration, NE);
          }

          for(count_neighbours = 0 ; count_neighbours < 8 ; count_neighbours ++) { 
            when updateNeighbor[iteration](int iter, std::vector<Particle> incoming) 
            serial "Receive Particles"{
                particles.insert( particles.end(), incoming.begin(), incoming.end());  
            }
          }
          
          //TODO: Add contribute calls for reductions of max and avg calculation
          if(0 == iteration%20) {
            serial "Ready to Migrate" {
	      AtSync();			
            } when ResumeFromSync(){} 
          }

        }//end of the iteration loop

        //TODO: Add contribute call for finishing the execution
        serial "Work Done" {
          contribute(CkCallback(CkReductionTarget(Main, done), mainProxy));
        }
    };
  };

  initproc void registerMaxAndAvg(void);
};
